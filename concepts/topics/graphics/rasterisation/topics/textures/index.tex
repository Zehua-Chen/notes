\chapter{Textures}

\begin{itemize}
  \item \textbf{Texture Mapping}: pastes pixels from an image onto
  simple geometric models; can be combined with shading to achieve lighting
  \item Each vertex contains a \textbf{(u, v) coordinate} that maps into the
  parametric texture surface ($ \left[ 0, 1 \right] $); enables using
  textures of different resolutions
  \begin{itemize}
    \item The space between vertices are interpolated (as in shading)
    \item Poor selection of texture coordinates lead to distortions
    \item the mismatch between texture size and number of fragments requires us
    to adjust how the textures are sampled, aka \textbf{texture filtering}
  \end{itemize}
\end{itemize}

\subimport{./}{filtering}

\section{Bump (Normal) Mapping}

  \begin{itemize}
    \item \textbf{Bump (normal) textures} encode the normal to use to render the
    surfaces (alters normal vectors during the rendering process);
    achieves bumpy surfaces without using many triangles.
    \item \textbf{Bump mapping}: applying bump textures
    \item \textbf{Normal maping}: a way of implementing bump mapping
  \end{itemize}

\section{Sprites vs Textures}

  \begin{itemize}
    \item \textbf{Sprite}:
    \item \textbf{Texture}
  \end{itemize}

\section{Environment Mapping}

  \begin{itemize}
    \item \textbf{Sphere Around Object}:
    \item \textbf{Cube Around Object}: uses 6 images to form a cube
    \begin{itemize}
      \item More efficient than sphere around object
      \item Two objects cannot reflect each other
      \item Frame rate drops (draw 6 times?)
    \end{itemize}
  \end{itemize}

\subimport{./}{shaders}
