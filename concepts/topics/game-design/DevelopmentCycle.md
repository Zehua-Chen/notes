# Overview

Iterative design is a cycle of conceptualization, prototyping, testing, and
evaluation. Iterative design is a form of the adaptive process. The adaptive
process is where the design went through cycles, whereas predicative the process
is where the design does not go through any cycles.

- **Conceptualization**: The concept of a game can be anything. There is no need
  to work out the details in conceptualization and concepts are mostly just
  questions.
- **Prototype**: Prototyping is where the idea is made into something tangible,
  but the prototype should remain focused on ideas and questions. Prototypes can
  be anything from rough performance to rough code.
- **Playtest**: Playtesting is where the designer uses the prototype to find the
  flaws of the concept. Using these flaws, the designer can improve their
  design. There are two kinds of playtesting, internal and external. Designers
  engage in internal playtesting by playing their prototype. Outsiders engage in
  external playtesting by playing the designers' prototype.
- **Evaluate**: Evaluation is where the feedback from playtesting is
  incorporated into a new version of the design. Some feedbacks are not
  straightforward and it takes experience to understand them.

# Prototype

Designers should focus on play experience in the prototyping stage. Play
experience involves experiences both inside the game and outside of the game
(ex. controllers). Prototypes should be made quickly and designers should not
form an emotional attachment to their designs. Each batch of changes to design
should be minimum, as one change can deliver a huge impact on the experience.
The paper prototype tries to simulate what would be on-screen. Physical
prototype simulates the feel of the game. Playable prototype models core game
activity and are usually the first digital prototype. The key of playable
prototyping is to focus on design values rather than editing design values to
improve the play experience. Art and sound prototypes are used to find art
directions. It can be developed in parallel to a playable prototype. An
interface prototype is used to validate the way players interact with the game,
ex. controllers and UIs. Code/tech prototype is used to layout the technical
infrastructure for more complete prototypes. Code prototype has two functions.
First, answering if it is possible to implement a kind of gameplay. Second,
developing core gameplay and make it feel right. Core game prototypes
incorporate all core areas of a game. Additional core game prototype can be
created once feedbacks are processed. The complete game prototype should be able
to be played from start to finish. The complete game prototype does not need to
be perfect; done in production. During the prototyping process, questions,
answers, changes, and tasks all need to be documented, so that we don't lose
track of the process.

# Playtests

- internal \textbf{Internal playtests} involves one developer or the team of
  developer that designs the game. It is important for a developer to playtest
  him/herself first before asking the team to playtest.
- game developer \textbf{Game developer playtests} involves developers that do
  not develop the game. Game developers have a wealth of knowledge but would
  sometimes make a suggestion on how they would make the game.
- family and friends \textbf{Family and friends playtests} involves people that
  the developers are comfortable sharing the game with. Family and friends'
  suggestions would be more positive, therefore it is important to pay more
  attention to what they do than what they say.
- target audience \textbf{Target audience playtests} happen in the core game and
  complete game prototypes and involve people that are in the target audience
  but do not know the game.
- new player \textbf{New player playtests} involves players new to the game and
  is intended to be used to find out how new players will approach the game. It
  is important to run between five and seven playtests. Since players are only
  new once, it is important to keep finding new players.
- experienced player \textbf{Experienced player playtests} involve players who
  would spend a long time with the prototype. These playtests help to
  investigate how design has translated into an experience and how changes in
  the game influence the experience, because of this, these playtests can happen
  in different stages of development.
- prototypes and playtests \textbf{Different playtests require different kinds
  of proottypes}. Paper, physical and code prototypes are best for internal, and
  game developer playtests. Art and playable prototypes are best for family and
  friends' playtests. Core game prototypes are best for target audience
  playtests. Complete game prototypes can be used with all kinds of playtests.
  Experienced playtesters can have all kinds of prototypes.
- prepare for playtests \textbf{Before playtests}, there are 3 things to do. 1.
  Pick a time and place for playtests, and prepare the right atmosphere. 2. Plan
  how to introduce the game, and prepare a list of questions that the playtest
  is supposed to answer. 3. Figure how to record feedback
- during playtests \textbf{During playtests}, there are 4 things to do. 1.
  Introduce the prototype, and let playtesters know it is not finished. 2.
  Observe players' experiences. 3. Listen to what players have to say. Maybe ask
  players to say out loud what they are doing. 4. Asks questions to find out
  players' reactions to the game. Target audience playtests also require
  discussion before playtests to collect their background information.
- after playtests \textbf{After playtests}, take notes on who the players are
  and their reaction to the game. Specifically, take notes on gameplay, how do
  playtesters respond to visual and audio, bugs found during playtesting and
  what leads to them, what playtesters have to say about the game, what has been
  observed from the playtesters, ideas that came to mind during playtesting
- feedback vs input When developers take player \textbf{inputs}, they will often
  make changes to suit their players, but when developers take player
  \textbf{feedback}, they will take what players have to say into account but do
  not necessarily make changes. Some developers use playtests to make sure that
  they deliver the experience they intended rather than make an experience that
  the player wants.
